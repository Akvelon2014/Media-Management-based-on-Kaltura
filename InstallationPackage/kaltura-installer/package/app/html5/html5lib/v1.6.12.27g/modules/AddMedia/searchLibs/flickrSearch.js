/**
 * Basic flickr search uses flickr jsonp api
 * http://www.flickr.com/services/api/
 *
 *
 * we look for licenses from method=flickr.photos.licenses.getInfo
 * per http://commons.wikimedia.org/wiki/Special:Upload?uselang=fromflickr
 * we are interested in:
 *	(4) Attribution License
 *	(5) Attribution-ShareAlike License,
 *	(7) No known copyright restrictions,
 *	(8) United States Government Work
 */

var flickrSearch = function ( options ) {
	this.init( options );
}
flickrSearch.prototype = {
	// @@todo probably would be good to read the api-key from configuration
	apikey : '2867787a545cc66c0bce6f2e57aca1d1',
	// What license we are interested in
	_license_keys: '4,5,7,8',
	_srctypes: ['t', 'sq', 's', 'm', 'o'],
	licenseMap: {
		'4' : 'http://creativecommons.org/licenses/by/3.0/',
		'5'	: 'http://creativecommons.org/licenses/by-sa/3.0/',
		'7'	: 'http://www.flickr.com/commons/usage/',
		'8' : 'http://www.usa.gov/copyright.shtml'
	},

	/**
	* Initialize the flickr Search with provided options
	*
	* @param {Object} options Initial options for the flickrSearch class
	*/
	init:function( options ) {
		var baseSearch = new baseRemoteSearch( options );
		for ( var i in baseSearch ) {
			if ( typeof this[i] == 'undefined' ) {
				this[i] = baseSearch[i];
			} else {
				this['parent_' + i] = baseSearch[i];
			}
		}
	},

	/**
	* Get the Search results setting _loading flag to false once results have been added
	*
	* Runs an api call then calls addResults with the resulting data
	* @param {String} search_query Text search string
	*/
	getProviderResults: function( search_query, callback ) {
		var _this = this;
		mw.log( "flickr::getProviderResults" );


		// setup the flickr request:
		var request = {
			'method':'flickr.photos.search',
			'format':'json',
			'license':this._license_keys,
			'api_key':this.apikey,
			'per_page': this.provider.limit,
			'page' : this.provider.offset,
			'text': search_query,
			'extras' :	'license, date_upload, date_taken, owner_name, icon_server, original_format, last_update, geo, tags, machine_tags, o_dims, views, media, path_alias, url_sq, url_t, url_s, url_m, url_o'
		}
		$j.getJSON( this.provider.apiUrl + '?jsoncallback=?', request, function( data ) {
			_this.addResults( data );
			callback( 'ok' );
		} );
	},
	/**
	* Adds results from fliker api data response object
	*
	* @param {Object} data Fliker response data
	*/
	addResults:function( data ) {
		var _this = this;
		if ( data.photos && data.photos.photo ) {
			// set result info:
			this.num_results = data.photos.total;
			if ( this.num_results > this.provider.offset + this.provider.limit ) {
				this.more_results = true;
			}
			for ( var resource_id in data.photos.photo ) {
				var flickrResource = data.photos.photo[ resource_id ];
				var resource = _this.getResourceObject( flickrResource );
				_this.resultsObj[ resource_id ] = resource;
			}
		}
	},
	/**
	* Maps a Fliker response object to a "resource object"
	*
	* @param {Object} flickrResource Fliker response resource
	*/
	getResourceObject: function( flickrResource ) {
		var _this = this;
		var resource = {
			'titleKey'	 : flickrResource.title + '.jpg',
			'resourceKey': flickrResource.id,
			'link'		 : _this.detailsUrl + flickrResource.pathalias + '/' + flickrResource.id,
			'title'		 : flickrResource.title,
			'thumbwidth' : flickrResource.width_t,
			'thumbheight': flickrResource.height_t,
			'desc'		 : flickrResource.title,
			// Set the license
			'license'	 : this.rsd.getLicenseFromUrl( _this.licenseMap[ flickrResource.license ] ),
			'pSobj'		 : _this,

			// Assume image/jpeg for flickr response
			'mime'		 : 'image/jpeg'
		};
		// Add all the provided src types that are avaliable
		resource['sizeKeys'] = { };
		for ( var i in _this._srctypes ) {
			var st = _this._srctypes[i];
			// If resource has a url add it to the sizeKeys:
			if ( flickrResource['url_' + st] ) {
				resource['sizeKeys'][st] = {
					'h' : flickrResource[ 'height_' + st ],
					'w' : flickrResource[ 'width_' + st ],
					'src' : flickrResource[ 'url_' + st ]
				}
				// Set src to the largest
				resource[ 'src' ] = flickrResource['url_' + st];
			}
		}
		return resource;
	},

	/**
	* Return image transform via callback
	*
	* @param {Object} resource Resource object
	* @param {Number} size Requested size
	* @param {Function} callback Callback is called directly
	*	since fliker includes image transforms in api response
	*/
	getImageObj:function( resource, size, callback ) {
		if ( size.width ) {
			var skey = this.getSizeKey( resource, size.width )
			callback ( {
				'url' : resource.sizeKeys[ skey ].src,
				'width' : resource.sizeKeys[ skey ].w,
				'height' : resource.sizeKeys[ skey ].h
			} );
		}
	},
	/**
	* Get an image transformation based a SrcTypeKey generated by the requested options
	*
	* @param {Object} resource Resource for image transform
	* @param {Object} options Options for image transform call
	*/
	getImageTransform:function( resource, options ) {
		if ( options.width ) {
			return resource.sizeKeys[ this.getSizeKey( resource, options.width ) ].src;
		}
		return resource.sizeKeys[ _srctypes[_srctypes.length-1] ];
	},

	/**
	* Get the size key for a requested width
	*
	* @param {Object} resource Resource for sizeKey grab
	* @param {Number} width Requested width for sizeKey lookup
	*/
	getSizeKey:function( resource, width ) {
		if ( width <= 75 ) {
			if ( resource.sizeKeys['sq'] )
				return 'sq';
		} else if ( width <= 100 ) {
			if ( resource.sizeKeys['t'] )
				return 't';
		} else if ( width <= 240 ) {
			if ( resource.sizeKeys['s'] )
				return 's';
		} else if ( width <= 500 ) {
			if ( resource.sizeKeys['m'] )
				return 'm';
		} else {
			if ( resource.sizeKeys['o'] )
				return 'o';
		}
		// original was missing return medium or small
		if ( resource.sizeKeys['m'] )
			return 'm';
		if ( resource.sizeKeys['s'] )
			return 's';

	}
}
