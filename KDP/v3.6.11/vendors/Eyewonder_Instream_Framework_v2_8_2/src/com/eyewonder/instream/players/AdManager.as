package com.eyewonder.instream.players {	import com.eyewonder.instream.InstreamFramework;	import com.eyewonder.instream.events.*;	import com.eyewonder.instream.modules.videoAdModule.VAST.utility.CacheBuster;		import flash.display.MovieClip;	import flash.events.EventDispatcher;		public dynamic class AdManager extends EventDispatcher{				private var instreamFramework:InstreamFramework;		private var _reminderListArray:Array;				public var config:Object = {			midroll_video_length: 100,			overlay_delay: 5,						preroll: undefined,			midroll: undefined,			postroll: undefined,			overlay: undefined,						volume: 100		}				public var adPlayed:Object = { };				private var _adPlaying:Boolean = false;		public function get adPlaying() : Boolean { return _adPlaying }; //read only				private var _adPaused:Boolean = false;		private var _overlayIsActive:Boolean = false;				private var _adType:String;		public function get adType() : String { return _adType }; //read only				/**		 * initializes the AdManager		 * 		 * @param	cfg		config object that holds some informations about the player and the ad urls		 * @param	p		the player's content movieclip, where the ads can be placed into		 */		public function AdManager( cfg:Object, player:MovieClip ) {			config = cfg;						_reminderListArray = new Array();						// reset the played state for every ad type			for (var i:int = 0; i < AdTypes.ALL_TYPES.length; i++)				adPlayed[AdTypes.ALL_TYPES[i]] = false;						var root_mc:MovieClip = new MovieClip();			root_mc.name = "uif";			player.addChild( root_mc );							instreamFramework = new InstreamFramework( root_mc );						instreamFramework.addEventListener( UIFEvent.CONTROL_EVENT, controlEventHandler );			instreamFramework.addEventListener( UIFEvent.TRACK_EVENT, trackEventHandler );			instreamFramework.addEventListener( UIFEvent.ERROR_EVENT, errorEventHandler );						instreamFramework.audioVolume = config.volume;						instreamFramework.config.width = cfg.width;//player.width;			instreamFramework.config.height = cfg.height;//player.height;			instreamFramework.config.x = player.x;			instreamFramework.config.y = player.y;		}		private function controlEventHandler( evt:UIFEvent ):void {					switch ( evt.info.type ) {				case UIFControlEvent.ON_END_AD:					OnEndAd();									break;				case UIFControlEvent.CONTENT_VID_PLAY:					// TODO: Add code to tell the player to play/resume the publisher's video									break;				case UIFControlEvent.CONTENT_VID_PAUSE:					// TODO: Add code to tell the player to pause the publisher's video				break;				case UIFControlEvent.CONTENT_VID_STOP:					// Note: This case may will be used with future releases. If so...					// TODO: Add code to tell the player to stop the publisher's video				break;				case UIFControlEvent.ON_REMINDER_DETECTED:					// Workaround: Save the reminder unit for later use (if the UIF is used as a loader and becomes cleared after an ad has finished)//					_reminderListArray = instreamFramework.reminderListArray;				break;				case UIFControlEvent.AD_REMAINING_TIME:					updateCountdown( evt.info.data['adRemainingTime'], evt.info.data['adTotalTime'] );				break;				// TODO: Add other cases to catch the following events:				/*  				 *	case UIFControlEvent.AD_INFORMATION_DATA				 *	case UIFControlEvent.ON_AD_LOAD_COMPLETE				 *	case UIFControlEvent.ON_START_PLAY_AD				 *	case UIFControlEvent.ON_START_REQUEST_AD				 *	case UIFControlEvent.ON_START_LINEAR				 *	case UIFControlEvent.ON_START_LINEAR_INTERACTIVE				 *	case UIFControlEvent.ON_START_OVERLAY				 *	case UIFControlEvent.ON_REMINDER_OVERRIDE				 *	case UIFControlEvent.ON_RESIZE_NOTIFY				 */								// TODO: Add those cases if the player does use a overlay-controller or something similar that is placed/added above the ad				// recommended to use with Interactive Linear and Overlay Ticker-Ads				/*				 *  case UIFControlEvent.HIDE_CONTROLS				 *  case UIFControlEvent.SHOW_CONTROLS				 */				// For more information look at the Instream Framework Specification				default: 					//instreamFramework._debugMessage(2, "unhandled Control Event: " + evt.info.type );				break;			}						//currently couldn'd dispacth the same event so i am dispat			//dispatchEvent( new Event(  , evt.info.type ) );			dispatchEvent( new UIFEvent( evt.type , evt.info ) );		}			private function trackEventHandler( evt:UIFEvent ):void {			switch ( evt.info.type ) {				case UIFTrackEvent.TRACK_LOAD:					instreamFramework._debugMessage(0, "trackEventHandler::" + evt.info );					break;				case UIFTrackEvent.TRACK_CLICKTHRU:				case UIFTrackEvent.TRACK_START_OF_VIDEO:				case UIFTrackEvent.TRACK_FIRST_QUARTILE_OF_VIDEO:				case UIFTrackEvent.TRACK_MID_OF_VIDEO:				case UIFTrackEvent.TRACK_THIRD_QUARTILE_OF_VIDEO:				case UIFTrackEvent.TRACK_END_OF_VIDEO:					var e:UIFTrackEvent = new UIFTrackEvent(evt.type, evt.info);					dispatchEvent(e);					break;								// TODO: Add other cases to catch the following events:				/*  				 *	case UIFTrackEvent.TRACK_EXPAND				 *	case UIFTrackEvent.TRACK_CONTRACT				 *	case UIFTrackEvent.TRACK_CLOSE				 *	case UIFTrackEvent.TRACK_INTERACTION				 *  case UIFTrackEvent.TRACK_GO_INTERACTIVE				 *  case UIFTrackEvent.TRACK_LEAVE_INTERACTIVE				 *  case UIFTrackEvent.TRACK_ENTER_FULLSCREEN				 */				// For more information look at the Instream Framework Specification				default: 					//instreamFramework._debugMessage(2, "unhandled Track Event: " + evt.info.type );					break;			}		}				private function errorEventHandler( evt:UIFEvent ):void {			// TODO: Publisher should add code here to handle the error-event			// Note: In parallel the Eyewonder Instream Framework is dispatching other events like UIFControlEvent.CONTENT_VID_PLAY that tells the player what to do next. So in most cases you can leave this method blank.		}				/**		 * starts an ad specified by type		 * removes any active ad prior to starting a new one, if there is any running		 * 		 * @param	type	type to start, see AdTypes		 * 		 * @return	true if ad started 		 */		public function startAd( type:String ):Boolean {			var url:String = config[type];						// overlays are allowed to start more than once, even if they have been played			if ( !isset(url) || 				(adPlayed[type] == true && type != AdTypes.OVERLAY))				return false;						removeAd(); // removes any active ad						var _adSlotType:String = "adSlotTypeUnknown";						// overlays			if ( type == AdTypes.OVERLAY ) {				_overlayIsActive = true;				_adSlotType = "adSlotTypeNonLinear";				// Workaround: Forward saved reminderUnit array before calling the overlay//				instreamFramework.reminderListArray = _reminderListArray;			} else { // fixedrolls				_adSlotType = "adSlotTypeLinear";					_adPlaying = true;				_overlayIsActive = false;			}						adPlayed[type] = true;			_adType = type;			_adPaused = false;						// tell the framework the new overlay_delay if there is a different this time arround			instreamFramework.config.overlay_delay = config.overlay_delay;						// set the bandwith detection file, if it happens to be changed thru a feed			instreamFramework.config.bwDetectProgressiveURL = config.bw_detection_file;						// finally start the ad			instreamFramework.loadAdURL( url, _adSlotType );						return true;		}				/**		 * removes ad		 */		public function removeAd():void {			if ( _adPlaying || _overlayIsActive ) {				instreamFramework._adIsPlaying = true;	// force ad is playing so any overlay gets removed aswell				instreamFramework.endAd();			}		}				/**		 * ad finished playing		 * continue movie playback		 */		private function OnEndAd():void {			_adPlaying = false;			_adPaused = false;		}				/**		 * gives the instreamFramework the new display dimensions it can use for the ad		 * and notifies the framework to resize any running ad.		 * 		 * @param	width		 * @param	height		 * @param	x		 * @param	y		 */		public function resize( width:Number, height:Number, x:Number, y:Number ):void {			instreamFramework.config.width = width;			instreamFramework.config.height = height;			instreamFramework.config.x = x;			instreamFramework.config.y = y;						instreamFramework.resizeNotify();		}				/**		 * called with each playhead-update for linear ad-types		 * allowes updating progress-bar and/or time displays of the player		 * 		 * @param	remaining - time in seconds		 * @param	total - time in seconds		 */		private function updateCountdown( remaining:Number, total:Number ):void {			// TODO: Publisher should add code to synch its custom countdown with the ad		}		/**		 * reset all variables		 * usually run on a new video start		 */		public function reset():void {			removeAd();			_adPlaying = false;			_overlayIsActive = false;			_adPaused = false;						_adType = undefined;						// reset played status for each ad type	/* 		for (var i:int = 0; i < AdTypes.ALL_TYPES.length; i++)				adPlayed[AdTypes.ALL_TYPES[i]] = false; */			adPlayed = new Object();									refreshCacheBuster();		}				/**		 * generate a new cachebuster		 * this should be called every video change.		 * 		 * ad's should have the same cachebuster number throughout a content video from start to finish		 * and change if the user switches the content video		 */		public function refreshCacheBuster():void {			instreamFramework._cacheBuster.randomizeCacheBuster(CacheBuster.VIDEO, true);		}				/**		 * tests if a string is set		 * 		 * @param	variable		 * 		 * @return	true if not empty, otherwise false		 */		private function isset( variable:String ):Boolean {			if ( ( variable != "" ) && ( variable != 'undefined' ) ) return true;					return false;		}	}}